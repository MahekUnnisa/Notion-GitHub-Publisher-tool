{"caption":[],"rich_text":[{"type":"text","text":{"content":"void insertAtPosition(Node* &tail, Node* &head, int position, int d) {\n\n\n    //insert at Start\n    if(position == 1) {\n        insertathead(head, d);\n        return;\n    }\n\n    Node* temp  = head;//temp me head rakhlo\n    int cnt = 1;//count karlo\n\n    while(cnt < position-1) {//kitne hai check karke rakhlo\n        temp = temp->next;\n        cnt++;\n    }\n\n    //inserting at Last Position\n    if(temp -> next == NULL) { \n        //agar temp ke next null hai it means last pe \n        //add karne ki koshish hori\n        insertatTail(tail,d);\n        return ;\n    }\n\n    //creating a node for d\n    Node* nodeToInsert = new Node(d);\n\n    nodeToInsert -> next = temp -> next;\n\n    temp -> next = nodeToInsert;\n}","link":null},"annotations":{"bold":false,"italic":false,"strikethrough":false,"underline":false,"code":false,"color":"default"},"plain_text":"void insertAtPosition(Node* &tail, Node* &head, int position, int d) {\n\n\n    //insert at Start\n    if(position == 1) {\n        insertathead(head, d);\n        return;\n    }\n\n    Node* temp  = head;//temp me head rakhlo\n    int cnt = 1;//count karlo\n\n    while(cnt < position-1) {//kitne hai check karke rakhlo\n        temp = temp->next;\n        cnt++;\n    }\n\n    //inserting at Last Position\n    if(temp -> next == NULL) { \n        //agar temp ke next null hai it means last pe \n        //add karne ki koshish hori\n        insertatTail(tail,d);\n        return ;\n    }\n\n    //creating a node for d\n    Node* nodeToInsert = new Node(d);\n\n    nodeToInsert -> next = temp -> next;\n\n    temp -> next = nodeToInsert;\n}","href":null}],"language":"c++"}{"caption":[],"rich_text":[{"type":"text","text":{"content":"void insertathead(Node* &head, int d){\n\n    //pehle ek new node cretae karenge with the data provided\n    Node* temp = new Node(d);\n    \n    //temp ke next pointer ko hum head ki taraf point kardenge\n    temp -> next = head;\n\n    //head ke andar temp ko dal denge\n    head = temp;\n\n    //abb ll kuchh aisi hogi\n    //temp(head pe pointing to before head)----> head(temp ki place pe)--->pointing to null\n\n}","link":null},"annotations":{"bold":false,"italic":false,"strikethrough":false,"underline":false,"code":false,"color":"default"},"plain_text":"void insertathead(Node* &head, int d){\n\n    //pehle ek new node cretae karenge with the data provided\n    Node* temp = new Node(d);\n    \n    //temp ke next pointer ko hum head ki taraf point kardenge\n    temp -> next = head;\n\n    //head ke andar temp ko dal denge\n    head = temp;\n\n    //abb ll kuchh aisi hogi\n    //temp(head pe pointing to before head)----> head(temp ki place pe)--->pointing to null\n\n}","href":null}],"language":"c++"}{"caption":[],"rich_text":[{"type":"text","text":{"content":"#include <iostream>\nusing namespace std;\n\nclass Node {\n    public:\n    int data;\n    Node* next;\n\n    //constructor\n\n    Node(int data){\n\n        this -> data = data;\n        this -> next = NULL;    \n    \n    }\n\n};\n\n//funation to insert a node at head place\n//takes a head node and dta which is to be inserted\nvoid insertathead(Node* &head, int d){\n\n    //pehle ek new node cretae karenge with the data provided\n    Node* temp = new Node(d);\n    \n    //temp ke next pointer ko hum head ki taraf point kardenge\n    temp -> next = head;\n\n    //head ke andar temp ko dal denge\n    head = temp;\n\n    //abb ll kuchh aisi hogi\n    //temp(head pe pointing to before head)----> head(temp ki place pe)--->pointing to null\n\n}\nvoid print(Node* &head){\n\n    if (head == NULL) {\n        cout << \"list is empty\";\n        return;\n    }\n    Node* temp = head;\n\n    while(temp!=NULL){\n\n        cout << temp -> data << \" \" ;\n        temp = temp -> next;\n    }\n    cout << endl;\n\n}\n\nint main(){\n    Node* node1 = new Node(10);\n    // cout << node1 -> data << endl;\n    // cout << node1 -> next << endl;\n\n    //first node hamari node1 hai thta is head node hai.\n    Node* head = node1;\n\n    print(head);\n    insertathead(head, 20);\n    print(head);\n\n    return 0;\n\n}","link":null},"annotations":{"bold":false,"italic":false,"strikethrough":false,"underline":false,"code":false,"color":"default"},"plain_text":"#include <iostream>\nusing namespace std;\n\nclass Node {\n    public:\n    int data;\n    Node* next;\n\n    //constructor\n\n    Node(int data){\n\n        this -> data = data;\n        this -> next = NULL;    \n    \n    }\n\n};\n\n//funation to insert a node at head place\n//takes a head node and dta which is to be inserted\nvoid insertathead(Node* &head, int d){\n\n    //pehle ek new node cretae karenge with the data provided\n    Node* temp = new Node(d);\n    \n    //temp ke next pointer ko hum head ki taraf point kardenge\n    temp -> next = head;\n\n    //head ke andar temp ko dal denge\n    head = temp;\n\n    //abb ll kuchh aisi hogi\n    //temp(head pe pointing to before head)----> head(temp ki place pe)--->pointing to null\n\n}\nvoid print(Node* &head){\n\n    if (head == NULL) {\n        cout << \"list is empty\";\n        return;\n    }\n    Node* temp = head;\n\n    while(temp!=NULL){\n\n        cout << temp -> data << \" \" ;\n        temp = temp -> next;\n    }\n    cout << endl;\n\n}\n\nint main(){\n    Node* node1 = new Node(10);\n    // cout << node1 -> data << endl;\n    // cout << node1 -> next << endl;\n\n    //first node hamari node1 hai thta is head node hai.\n    Node* head = node1;\n\n    print(head);\n    insertathead(head, 20);\n    print(head);\n\n    return 0;\n\n}","href":null}],"language":"c++"}{"caption":[],"rich_text":[{"type":"text","text":{"content":"#include <iostream>\nusing namespace std;\n\nclass Node {\n    public:\n    int data;\n    Node* next;\n\n    //constructor\n    Node(int data){\n        this -> data = data;\n        this -> next = NULL;\n    }\n\n    //destructor\n    ~Node(){\n        int value = this -> data;\n        if (this -> next != NULL){\n            delete next;\n            next =NULL;\n        }\n        cout << \"memory is free\" << value << endl;\n    }\n\n};\n\n//function to insert node whrever you want\nvoid insertNode(Node* &tail, int element, int d) {\n    \n\n    //empty list\n    if(tail == NULL) {\n        Node* newNode = new Node(d);\n        tail = newNode;\n        newNode -> next = newNode;\n    }\n    else{\n        //non-empty list\n        //assuming that the element is present in the list\n\n        Node* curr = tail;\n\n        while(curr->data != element) {\n            curr = curr -> next;\n        }\n        \n        //element found -> curr is representing element wala node\n        Node* temp = new Node(d);\n        temp -> next = curr -> next;\n        curr -> next = temp;\n\n    }\n\n}    \nvoid deleteNode(Node* &tail, int value){\n    //empty list\n    if (tail == NULL){\n        cout << \"leist is empty, check aro\" << endl;\n        return;\n    }\n    else{\n        //non - empty\n        //assuming value is there in the list\n\n        Node* prev = tail;\n        Node* curr = prev -> next;\n\n        while (curr -> data != value){\n            prev = curr;\n            curr =  curr -> next;\n        }\n\n        prev -> next = curr -> next;\n        \n        //one node linked list\n        if(curr == prev) {\n            tail = NULL;\n        }\n\n        //2 node linked list\n        else if(tail == curr){\n            tail = prev;\n        }\n        curr -> next = NULL;\n        delete curr;\n    }\n\n}\n\n//function to print the linked list\nvoid print(Node* tail){\n    Node* temp = tail;\n\n    //empty list\n    if(tail == NULL) {\n        cout << \"List is Empty \"<< endl;\n        return ;\n    }\n\n    do {\n        cout << tail -> data << \" \";\n        tail = tail -> next;\n    } while (tail != temp); \n        \n    cout << endl;\n}\n\nint main() {\n    Node* tail = NULL;\n\n    insertNode(tail, 5, 3);\n    print(tail);\n    insertNode(tail, 3, 4);\n    print(tail);\n    /*insertNode(tail, 4, 5);\n    print(tail);\n    insertNode(tail, 5, 6);\n    print(tail);\n    insertNode(tail, 6, 60);\n    print(tail);\n    insertNode(tail, 4, 40);\n    print(tail);*/\n    deleteNode(tail, 3);\n    print(tail);\n    return 0;\n}","link":null},"annotations":{"bold":false,"italic":false,"strikethrough":false,"underline":false,"code":false,"color":"default"},"plain_text":"#include <iostream>\nusing namespace std;\n\nclass Node {\n    public:\n    int data;\n    Node* next;\n\n    //constructor\n    Node(int data){\n        this -> data = data;\n        this -> next = NULL;\n    }\n\n    //destructor\n    ~Node(){\n        int value = this -> data;\n        if (this -> next != NULL){\n            delete next;\n            next =NULL;\n        }\n        cout << \"memory is free\" << value << endl;\n    }\n\n};\n\n//function to insert node whrever you want\nvoid insertNode(Node* &tail, int element, int d) {\n    \n\n    //empty list\n    if(tail == NULL) {\n        Node* newNode = new Node(d);\n        tail = newNode;\n        newNode -> next = newNode;\n    }\n    else{\n        //non-empty list\n        //assuming that the element is present in the list\n\n        Node* curr = tail;\n\n        while(curr->data != element) {\n            curr = curr -> next;\n        }\n        \n        //element found -> curr is representing element wala node\n        Node* temp = new Node(d);\n        temp -> next = curr -> next;\n        curr -> next = temp;\n\n    }\n\n}    \nvoid deleteNode(Node* &tail, int value){\n    //empty list\n    if (tail == NULL){\n        cout << \"leist is empty, check aro\" << endl;\n        return;\n    }\n    else{\n        //non - empty\n        //assuming value is there in the list\n\n        Node* prev = tail;\n        Node* curr = prev -> next;\n\n        while (curr -> data != value){\n            prev = curr;\n            curr =  curr -> next;\n        }\n\n        prev -> next = curr -> next;\n        \n        //one node linked list\n        if(curr == prev) {\n            tail = NULL;\n        }\n\n        //2 node linked list\n        else if(tail == curr){\n            tail = prev;\n        }\n        curr -> next = NULL;\n        delete curr;\n    }\n\n}\n\n//function to print the linked list\nvoid print(Node* tail){\n    Node* temp = tail;\n\n    //empty list\n    if(tail == NULL) {\n        cout << \"List is Empty \"<< endl;\n        return ;\n    }\n\n    do {\n        cout << tail -> data << \" \";\n        tail = tail -> next;\n    } while (tail != temp); \n        \n    cout << endl;\n}\n\nint main() {\n    Node* tail = NULL;\n\n    insertNode(tail, 5, 3);\n    print(tail);\n    insertNode(tail, 3, 4);\n    print(tail);\n    /*insertNode(tail, 4, 5);\n    print(tail);\n    insertNode(tail, 5, 6);\n    print(tail);\n    insertNode(tail, 6, 60);\n    print(tail);\n    insertNode(tail, 4, 40);\n    print(tail);*/\n    deleteNode(tail, 3);\n    print(tail);\n    return 0;\n}","href":null}],"language":"c++"}{"caption":[],"rich_text":[{"type":"text","text":{"content":"#include <algorithm>\nbool cmp(vector<int>&a, vector<int> &b){\n    return a[2] < b[2];\n}\nvoid makeSet(vector<int> &parent, vector<int> &rank, int n){\n    for(int i=0; i<n; i++){\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n int findParent(vector<int> &parent, int node){\n     if(parent[node] == node){\n         return node;\n     }\n     return parent[node] = findParent(parent, parent[node]);\n }\nvoid unionSet(int u, int v, vector<int>&parent, vector<int>&rank){\n    u = findParent(parent, u);\n    v = findParent(parent, v);\n    \n    if(rank[u] < rank[v]){\n        parent[u] = v;\n    }\n    else if(rank[v] < rank[u]){\n        parent[v] = u;\n    }\n    else{\n        parent[v] = u;\n        rank[u]++;\n    }\n}\nint minimumSpanningTree(vector<vector<int>>& edges, int n)\n{\n    sort(edges.begin(), edges.end(), cmp);\n    vector<int>parent(n);\n    vector<int> rank(n);\n    makeSet(parent, rank, n);\n    int minweight = 0;\n    for(int i=0; i< edges.size(); i++){\n        int u = findParent(parent, edges[i][0]);\n        int v = findParent(parent, edges[i][1]);\n        int w = edges[i][2];\n        \n        if(u != v){\n            minweight += w;\n            unionSet(u, v, parent, rank);\n        }\n    }\n    return minweight;\n}","link":null},"annotations":{"bold":false,"italic":false,"strikethrough":false,"underline":false,"code":false,"color":"default"},"plain_text":"#include <algorithm>\nbool cmp(vector<int>&a, vector<int> &b){\n    return a[2] < b[2];\n}\nvoid makeSet(vector<int> &parent, vector<int> &rank, int n){\n    for(int i=0; i<n; i++){\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n int findParent(vector<int> &parent, int node){\n     if(parent[node] == node){\n         return node;\n     }\n     return parent[node] = findParent(parent, parent[node]);\n }\nvoid unionSet(int u, int v, vector<int>&parent, vector<int>&rank){\n    u = findParent(parent, u);\n    v = findParent(parent, v);\n    \n    if(rank[u] < rank[v]){\n        parent[u] = v;\n    }\n    else if(rank[v] < rank[u]){\n        parent[v] = u;\n    }\n    else{\n        parent[v] = u;\n        rank[u]++;\n    }\n}\nint minimumSpanningTree(vector<vector<int>>& edges, int n)\n{\n    sort(edges.begin(), edges.end(), cmp);\n    vector<int>parent(n);\n    vector<int> rank(n);\n    makeSet(parent, rank, n);\n    int minweight = 0;\n    for(int i=0; i< edges.size(); i++){\n        int u = findParent(parent, edges[i][0]);\n        int v = findParent(parent, edges[i][1]);\n        int w = edges[i][2];\n        \n        if(u != v){\n            minweight += w;\n            unionSet(u, v, parent, rank);\n        }\n    }\n    return minweight;\n}","href":null}],"language":"c++"}{"caption":[],"rich_text":[{"type":"text","text":{"content":"#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass Node{\n    public:\n        int data;\n        Node* left;\n        Node* right;\n\n    Node(int d){\n        this -> data = d;\n        this -> left = NULL;\n        this -> right = NULL;\n    }\n};\n\nNode* inserttoBST(Node* &root, int value){\n    if (root == NULL){\n        root = new Node(value);\n        return root;\n    }\n    if (value < root->data){\n        root -> left = inserttoBST(root-> left, value);\n\n    }\n    else{\n        root -> right = inserttoBST(root -> right, value);\n    }\n    return root;\n}\n\nvoid takeinput(Node* &root){\n    cout << \"Enter a value: \" << \" \";\n    int value;\n    cin >> value;\n\n    if(value == -1){\n        return;\n        cin >> value;\n    }\n\n    while (value != -1){\n        root = inserttoBST(root, value);\n        cin >> value;\n    }\n}\nvoid buildfromLevelOrder(Node* & root){\n    queue<Node*>q;\n    cout << \" enter the data:\" << \" \";\n    int value;\n    cin >> value;\n    \n    root = new Node(value);\n\n    q.push(root);\n\n    while(!q.empty()){\n        Node* temp = q.front();\n        q.pop();\n\n        cout << \"enter the data for left node:\" << \" \" << temp->left << endl;\n        int leftdata;\n        cin >> leftdata;\n\n        if(leftdata!=1){\n            temp -> left = new Node(leftdata);\n            q.push(temp -> left);\n        }\n        cout << \"enter the data for right node:\" << \" \" << temp->right << endl;\n        int rightdata;\n        cin >> rightdata;\n\n        if(rightdata!=1){\n            temp -> right = new Node(rightdata);\n            q.push(temp -> right);\n        }\n    }\n}\nvoid levelOrderTraversal(Node* root){\n    queue <Node*> q;\n    q.push(root);\n    q.push(NULL);\n    \n\n    while(!q.empty()){\n        Node* temp = q.front();\n        q.pop();\n        \n\n        if(temp == NULL){\n            cout << endl;\n\n            if(!q.empty()){\n                q.push(NULL);\n            }\n        }\n        else{\n            cout << temp -> data << \" \";\n            if(temp -> left){\n                q.push(temp -> left);\n            }\n            if(temp -> right){\n                q.push(temp -> right);\n            }\n        }\n\n    }\n}\nNode* minvalue(Node* root){\n    if(root == NULL){\n        return root;\n    }\n    Node* temp = root;\n    while (temp -> left != NULL){\n        temp = temp-> left;\n        return temp -> left;\n    }\n}\n\nNode* maxvalue(Node* root){\n    if(root==NULL){\n        return root;\n    }\n    Node* temp = root;\n    while (temp -> right !=NULL){\n        temp =temp-> right;\n    }\n    return temp -> right;\n}\n\n\nNode* deletefromBST(Node* root, int val){\n    //base case\n    if(root == NULL){\n        return root;\n    }\n\n    if (root -> data == val){\n        // 0child\n        if((root -> left ==NULL) && (root -> right == NULL)){\n            delete root;\n            return NULL;\n        }\n\n        //1 child//left child\n        if((root -> left!=NULL) && (root-> right==NULL)){\n            Node* temp = root -> left;\n            delete root;\n            return temp;\n        }\n\n        //right child\n        if((root -> left == NULL) && (root->right !=NULL)){\n            Node* temp = root -> right;\n            delete root;\n            return temp;\n        }\n        //2child\n        if((root -> left!=NULL )&& (root -> right != NULL)){\n            int mini;\n            mini = (minvalue(root->right)) -> data;\n            root -> data = mini;\n            root -> right = deletefromBST(root->right, mini);\n            return root;\n        }\n    }\n    else if( root -> data < val){\n        root -> right = deletefromBST(root -> right, val);\n        return root;\n    }\n    else if ( root-> data > val){\n        root -> left = deletefromBST(root-> left, val);\n        return root;\n\n    }\n}\n\n\nvoid InOrder(Node* root){\n    //LNR\n    //base call\n    if(root == NULL){\n        return;\n    }\n    InOrder(root -> left);\n    cout << root -> data << \" \";\n    InOrder(root -> right);\n\n}\nvoid PreOrder(Node* root){\n    //NLR\n    //base call\n    if(root == NULL){\n        return;\n    }\n    \n    cout << root -> data << \" \";\n    PreOrder(root -> left);\n    PreOrder(root -> right);\n    \n\n}\nvoid PostOrder(Node* root){\n    //LRN\n    //base call\n    if(root == NULL){\n        return;\n    }\n    PostOrder(root -> left);\n    PostOrder(root -> right);\n    cout << root -> data << \" \";\n    \n\n}\n\n\nint main(){\n    Node* root = NULL;\n    takeinput(root);\n\n    cout << \"levelorder traversal\"<< endl;\n    levelOrderTraversal(root);\n\n    cout << \"inorder traveral\" << endl;\n    InOrder(root) ;\n    cout<< endl;\n    //50 20 70 10 30 90 110 -1\n    cout << \"deleting node\" << endl;\n    root = deletefromBST(root, 30);\n\n    //mainjsc\n\n    cout << \"levelorder traversal\"<< endl;\n    levelOrderTraversal(root);\n\n    cout << \"inorder traveral\" << endl;\n    InOrder(root);\n    \n\n    return 0;\n\n}","link":null},"annotations":{"bold":false,"italic":false,"strikethrough":false,"underline":false,"code":false,"color":"default"},"plain_text":"#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass Node{\n    public:\n        int data;\n        Node* left;\n        Node* right;\n\n    Node(int d){\n        this -> data = d;\n        this -> left = NULL;\n        this -> right = NULL;\n    }\n};\n\nNode* inserttoBST(Node* &root, int value){\n    if (root == NULL){\n        root = new Node(value);\n        return root;\n    }\n    if (value < root->data){\n        root -> left = inserttoBST(root-> left, value);\n\n    }\n    else{\n        root -> right = inserttoBST(root -> right, value);\n    }\n    return root;\n}\n\nvoid takeinput(Node* &root){\n    cout << \"Enter a value: \" << \" \";\n    int value;\n    cin >> value;\n\n    if(value == -1){\n        return;\n        cin >> value;\n    }\n\n    while (value != -1){\n        root = inserttoBST(root, value);\n        cin >> value;\n    }\n}\nvoid buildfromLevelOrder(Node* & root){\n    queue<Node*>q;\n    cout << \" enter the data:\" << \" \";\n    int value;\n    cin >> value;\n    \n    root = new Node(value);\n\n    q.push(root);\n\n    while(!q.empty()){\n        Node* temp = q.front();\n        q.pop();\n\n        cout << \"enter the data for left node:\" << \" \" << temp->left << endl;\n        int leftdata;\n        cin >> leftdata;\n\n        if(leftdata!=1){\n            temp -> left = new Node(leftdata);\n            q.push(temp -> left);\n        }\n        cout << \"enter the data for right node:\" << \" \" << temp->right << endl;\n        int rightdata;\n        cin >> rightdata;\n\n        if(rightdata!=1){\n            temp -> right = new Node(rightdata);\n            q.push(temp -> right);\n        }\n    }\n}\nvoid levelOrderTraversal(Node* root){\n    queue <Node*> q;\n    q.push(root);\n    q.push(NULL);\n    \n\n    while(!q.empty()){\n        Node* temp = q.front();\n        q.pop();\n        \n\n        if(temp == NULL){\n            cout << endl;\n\n            if(!q.empty()){\n                q.push(NULL);\n            }\n        }\n        else{\n            cout << temp -> data << \" \";\n            if(temp -> left){\n                q.push(temp -> left);\n            }\n            if(temp -> right){\n                q.push(temp -> right);\n            }\n        }\n\n    }\n}\nNode* minvalue(Node* root){\n    if(root == NULL){\n        return root;\n    }\n    Node* temp = root;\n    while (temp -> left != NULL){\n        temp = temp-> left;\n        return temp -> left;\n    }\n}\n\nNode* maxvalue(Node* root){\n    if(root==NULL){\n        return root;\n    }\n    Node* temp = root;\n    while (temp -> right !=NULL){\n        temp =temp-> right;\n    }\n    return temp -> right;\n}\n\n\nNode* deletefromBST(Node* root, int val){\n    //base case\n    if(root == NULL){\n        return root;\n    }\n\n    if (root -> data == val){\n        // 0child\n        if((root -> left ==NULL) && (root -> right == NULL)){\n            delete root;\n            return NULL;\n        }\n\n        //1 child//left child\n        if((root -> left!=NULL) && (root-> right==NULL)){\n            Node* temp = root -> left;\n            delete root;\n            return temp;\n        }\n\n        //right child\n        if((root -> left == NULL) && (root->right !=NULL)){\n            Node* temp = root -> right;\n            delete root;\n            return temp;\n        }\n        //2child\n        if((root -> left!=NULL )&& (root -> right != NULL)){\n            int mini;\n            mini = (minvalue(root->right)) -> data;\n            root -> data = mini;\n            root -> right = deletefromBST(root->right, mini);\n            return root;\n        }\n    }\n    else if( root -> data < val){\n        root -> right = deletefromBST(root -> right, val);\n        return root;\n    }\n    else if ( root-> data > val){\n        root -> left = deletefromBST(root-> left, val);\n        return root;\n\n    }\n}\n\n\nvoid InOrder(Node* root){\n    //LNR\n    //base call\n    if(root == NULL){\n        return;\n    }\n    InOrder(root -> left);\n    cout << root -> data << \" \";\n    InOrder(root -> right);\n\n}\nvoid PreOrder(Node* root){\n    //NLR\n    //base call\n    if(root == NULL){\n        return;\n    }\n    \n    cout << root -> data << \" \";\n    PreOrder(root -> left);\n    PreOrder(root -> right);\n    \n\n}\nvoid PostOrder(Node* root){\n    //LRN\n    //base call\n    if(root == NULL){\n        return;\n    }\n    PostOrder(root -> left);\n    PostOrder(root -> right);\n    cout << root -> data << \" \";\n    \n\n}\n\n\nint main(){\n    Node* root = NULL;\n    takeinput(root);\n\n    cout << \"levelorder traversal\"<< endl;\n    levelOrderTraversal(root);\n\n    cout << \"inorder traveral\" << endl;\n    InOrder(root) ;\n    cout<< endl;\n    //50 20 70 10 30 90 110 -1\n    cout << \"deleting node\" << endl;\n    root = deletefromBST(root, 30);\n\n    //mainjsc\n\n    cout << \"levelorder traversal\"<< endl;\n    levelOrderTraversal(root);\n\n    cout << \"inorder traveral\" << endl;\n    InOrder(root);\n    \n\n    return 0;\n\n}","href":null}],"language":"c++"}